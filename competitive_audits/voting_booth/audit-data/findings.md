### [M-1] ROUNDING INCONSISTENCY IN REWARD DISTRIBUTION

**Description:**
The contract has a bug in the \_distributeRewards function related to the calculation of rewardPerVoter. Specifically, the initial calculation of rewardPerVoter uses integer division (totalRewards / totalVotes) for all voters, and then attempts to recalculate it for the last voter using Math.mulDiv with Math.Rounding.Ceil. This inconsistency may lead to rounding errors and result in an incorrect distribution of rewards, impacting the fairness of the reward allocation.

**Impact:**
The bug may lead to discrepancies in the distribution of rewards among voters, potentially favoring the last voter with a slightly higher reward due to inconsistent rounding. While this does not directly compromise the security of the contract, it affects the expected behavior and fairness of the reward distribution.

**Proof of Concept:**
The issue can be observed by analyzing the code logic in the \_distributeRewards function, specifically in the section where rewardPerVoter is calculated. By identifying the inconsistency in rounding methods, one can understand the potential impact on the final reward distribution.

**Recommended Mitigation:**
To address this issue, it is recommended to consistently calculate rewardPerVoter for all voters using Math.mulDiv with Math.Rounding.Ceil throughout the loop. This ensures uniform rounding and prevents potential discrepancies in reward distribution. The corrected code should resemble the following:

```javascript
// if the proposal passed so distribute rewards to the `For` voters
else {
  for (uint256 i; i < totalVotesFor; ++i) {
  rewardPerVoter = Math.mulDiv(totalRewards, 1, totalVotes, Math.Rounding.Ceil);
  \_sendEth(s_votersFor[i], rewardPerVoter);
}
}
```

This modification ensures that consistent rounding is applied to all voters, maintaining fairness in the reward distribution. Additionally, thorough testing should be conducted to validate the corrected implementation and ensure proper functionality.

## L-1: Solidity pragma should be specific, not wide

Consider using a specific version of Solidity in your contracts instead of a wide version. For example, instead of `pragma solidity ^0.8.0;`, use `pragma solidity 0.8.0;`

- Found in src/VotingBooth.sol [Line: 2](src/VotingBooth.sol#L2)

  ```solidity
  pragma solidity ^0.8.23;
  ```

## L-2: PUSH0 is not supported by all chains

Solc compiler version 0.8.20 switches the default target EVM version to Shanghai, which means that the generated bytecode will include PUSH0 opcodes. Be sure to select the appropriate EVM version in case you intend to deploy on a chain other than mainnet like L2 chains that may not support PUSH0, otherwise deployment of your contracts will fail.

- Found in src/VotingBooth.sol [Line: 2](src/VotingBooth.sol#L2)

  ```solidity
  pragma solidity ^0.8.23;
  ```
